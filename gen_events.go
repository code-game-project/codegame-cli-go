package main

import (
	"bufio"
	"fmt"
	"io"
	"strings"

	"github.com/code-game-project/cge-parser/adapter"
	"github.com/code-game-project/cli-utils/casing"
)

type eventDefinitionGenerator struct {
	builder strings.Builder
}

func generateEventDefinitions(target io.Writer, packageName, libraryURL string, cgeData adapter.ParserResponse) {
	g := eventDefinitionGenerator{}

	file := bufio.NewWriter(target)

	needsImport := false

	g.generateConfig(cgeData.Config)
	for _, e := range cgeData.Enums {
		g.generateEnum(e)
	}
	for _, t := range cgeData.Types {
		g.generateType(t)
	}
	for _, c := range cgeData.Commands {
		needsImport = true
		g.generateCommand(c)
	}
	for _, e := range cgeData.Events {
		needsImport = true
		g.generateEvent(e)
	}

	fmt.Fprintf(file, "package %s\n", packageName)

	fmt.Fprintln(file, `
/*
This code was generated by codegame-cli-go.

CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
THE CODE IS REGENERATED.
*/`)

	if needsImport {
		fmt.Fprintf(file, "\nimport \"%s\"\n", libraryURL)
	}

	file.WriteString(g.builder.String())
	file.Flush()
}

func (g *eventDefinitionGenerator) generateConfig(object adapter.Object) {
	g.builder.WriteString("\n")
	g.generateComments("", strings.Split(object.Comment, "\n"))
	g.builder.WriteString("type GameConfig struct {\n")

	g.generateProperties(object.Properties)

	g.builder.WriteString("}\n")
}

func (g *eventDefinitionGenerator) generateCommand(object adapter.Object) {
	g.builder.WriteString("\n")
	g.generateComments("", strings.Split(object.Comment, "\n"))
	g.builder.WriteString(fmt.Sprintf("const %sCmd cg.CommandName = \"%s\"\n\n", casing.ToPascal(object.Name), object.Name))
	g.builder.WriteString(fmt.Sprintf("type %sCmdData struct {\n", casing.ToPascal(object.Name)))

	g.generateProperties(object.Properties)

	g.builder.WriteString("}\n")
}

func (g *eventDefinitionGenerator) generateEvent(object adapter.Object) {
	g.builder.WriteString("\n")
	g.generateComments("", strings.Split(object.Comment, "\n"))
	g.builder.WriteString(fmt.Sprintf("const %sEvent cg.EventName = \"%s\"\n\n", casing.ToPascal(object.Name), object.Name))
	g.builder.WriteString(fmt.Sprintf("type %sEventData struct {\n", casing.ToPascal(object.Name)))

	g.generateProperties(object.Properties)

	g.builder.WriteString("}\n")
}

func (g *eventDefinitionGenerator) generateType(object adapter.Object) {
	g.builder.WriteString("\n")
	g.generateComments("", strings.Split(object.Comment, "\n"))
	g.builder.WriteString(fmt.Sprintf("type %s struct {\n", casing.ToPascal(object.Name)))

	g.generateProperties(object.Properties)

	g.builder.WriteString("}\n")
}

func (g *eventDefinitionGenerator) generateEnum(object adapter.Object) {
	g.builder.WriteString("\n")
	g.generateComments("", strings.Split(object.Comment, "\n"))
	g.builder.WriteString(fmt.Sprintf("type %s string\n", casing.ToPascal(object.Name)))
	if len(object.Properties) > 0 {
		g.builder.WriteString("\nconst (\n")
		for _, property := range object.Properties {
			g.generateComments("\t", strings.Split(property.Comment, "\n"))
			g.builder.WriteString(fmt.Sprintf("\t%s%s %s = \"%s\"\n", casing.ToPascal(object.Name), casing.ToPascal(property.Name), casing.ToPascal(object.Name), property.Name))
		}
		g.builder.WriteString(")\n")
	}
}

func (g *eventDefinitionGenerator) generateProperties(properties []adapter.Property) {
	for _, property := range properties {
		g.generateComments("\t", strings.Split(property.Comment, "\n"))
		g.builder.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", casing.ToPascal(property.Name), g.goType(property.Type.Type, property.Type.Name, property.Type.Generic), property.Name))
	}
}

func (g *eventDefinitionGenerator) generateComments(indent string, comments []string) {
	for i, comment := range comments {
		if i == 0 && comment == "" {
			continue
		}
		g.builder.WriteString(indent + "// " + comment + "\n")
	}
}

func (g *eventDefinitionGenerator) goType(dataType adapter.DataType, lexeme string, generic *adapter.PropertyType) string {
	switch dataType {
	case adapter.DTString:
		return "string"
	case adapter.DTBool:
		return "bool"
	case adapter.DTInt32:
		return "int"
	case adapter.DTInt64:
		return "int64"
	case adapter.DTFloat32:
		return "float32"
	case adapter.DTFloat64:
		return "float64"
	case adapter.DTList:
		return "[]" + g.goType(generic.Type, generic.Name, generic.Generic)
	case adapter.DTMap:
		return "map[string]" + g.goType(generic.Type, generic.Name, generic.Generic)
	case adapter.DTCustom:
		return casing.ToPascal(lexeme)
	}
	return "any"
}
