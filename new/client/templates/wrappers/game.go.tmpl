package {{.PackageName}}

/*
This code was generated by codegame-cli-go.

CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
THE CODE IS REGENERATED.
*/

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/code-game-project/go-client/cg"
	"github.com/spf13/pflag"
)

var URL string

func init() {
	url := os.Getenv("CG_GAME_URL")
	if url != "" {
		URL = url
	}
}

type Game struct {
	Id         string
	socket     *cg.Socket
	spectating bool
}

// If IsSpectating returns true, the session of this game will be empty and no events can be sent.
func (g *Game) IsSpectating() bool {
	return g.spectating
}

type Player struct {
	Id       string
	Username string
}

// Init parses command line arguments with pflag and calls either CreateAndJoinGame, CreateAndSpectateGame, JoinGame, SpectateGame or ReconnectGame depending on the provided commands:
//
//     Operations:\n")
//         create <username>          Create a new game.
//         join <game_id> <username>  Join an existing game.
//         reconnect <username>       Reconnect to a previous session.
//     Flags:
//         --public    Make the created game public.
//         --spectate  Spectate the created/joined game. The username is not neccessary if this flag is set.
//
// This function calls pflag.Parse() internally. If you want to add your own flags, you will need to register them with pflag *before* calling this function.
func Init() (*Game, error) {
	pflag.Usage = func() {
		fmt.Fprintf(os.Stderr, "USAGE: %s [OPTIONS] <operation>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\nOperations:\n")
		fmt.Fprintf(os.Stderr, "  create <username>          Create a new game.\n")
		fmt.Fprintf(os.Stderr, "  join <game_id> <username>  Join an existing game.\n")
		fmt.Fprintf(os.Stderr, "  reconnect <username>       Reconnect to a previous session.\n")
		fmt.Fprintf(os.Stderr, "\nFlags:\n")
		pflag.PrintDefaults()
	}

	var public bool
	pflag.BoolVarP(&public, "public", "p", false, "Make the created game public.")
	var spectate bool
	pflag.BoolVarP(&spectate, "spectate", "s", false, "Spectate the created/joined game. The username is not neccessary if this flag is set.")
	pflag.Parse()

	var operation string
	if pflag.NArg() > 1 || (spectate && pflag.NArg() > 0) {
		operation = strings.ToLower(pflag.Arg(0))
	} else {
		pflag.Usage()
		os.Exit(1)
	}

	if URL == "" {
		return nil, errors.New("CG_GAME_URL is empty.")
	}

	var game *Game
	var err error
	switch operation {
	case "create":
		if spectate {
			game, err = CreateAndSpectateGame(public)
		} else {
			game, err = CreateAndJoinGame(public, pflag.Arg(1))
		}
	case "join":
		if (!spectate && pflag.NArg() < 3) || (spectate && pflag.NArg() < 2) {
			fmt.Fprintln(os.Stderr, "No game_id specified!")
			pflag.Usage()
			os.Exit(1)
		}
		if spectate {
			game, err = SpectateGame(pflag.Arg(1))
		} else {
			game, err = JoinGame(pflag.Arg(1), pflag.Arg(2))
		}
	case "reconnect":
		game, err = ReconnectGame(pflag.Arg(1))
	default:
		fmt.Fprintf(os.Stderr, "Invalid operation '%s'!\n", operation)
		pflag.Usage()
		os.Exit(1)
	}
	if err != nil {
		return nil, err
	}

	return game, nil
}

// CreateAndJoinGame creates a new game and joins it immediately after.
func CreateAndJoinGame(public bool, username string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	gameId, err := socket.Create(public)
	if err != nil {
		return nil, fmt.Errorf("failed to create game: %s", err)
	}

	err = socket.Join(gameId, username)
	if err != nil {
		return nil, fmt.Errorf("failed to join game: %s", err)
	}

	return &Game{
		Id:     gameId,
		socket: socket,
	}, nil
}

// CreateAndSpectateGame creates a new game and spectates it immediately after.
func CreateAndSpectateGame(public bool) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	gameId, err := socket.Create(public)
	if err != nil {
		return nil, fmt.Errorf("failed to create game: %s", err)
	}

	err = socket.Spectate(gameId)
	if err != nil {
		return nil, fmt.Errorf("failed to spectate game: %s", err)
	}

	return &Game{
		Id:     gameId,
		socket: socket,
	}, nil
}

// JoinGame joins the game with the specified id.
func JoinGame(gameId, username string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Join(gameId, username)
	if err != nil {
		return nil, fmt.Errorf("failed to join game: %s", err)
	}

	return &Game{
		Id:     gameId,
		socket: socket,
	}, nil
}

// ReconnectGame joins a previous session from the session store.
func ReconnectGame(username string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.RestoreSession(username)
	if err != nil {
		return nil, fmt.Errorf("failed to reconnect: %s", err)
	}

	return &Game{
		Id:     socket.Session().GameId,
		socket: socket,
	}, nil
}

// SpectateGame joins a game as a spectator.
func SpectateGame(gameId string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Spectate(gameId)
	if err != nil {
		return nil, fmt.Errorf("failed to spectate game: %s", err)
	}

	return &Game{
		Id:     socket.Session().GameId,
		socket: socket,
	}, nil
}

// Run starts the event loop (blocking).
func (g *Game) Run() error {
	return g.socket.RunEventLoop()
}

// Update looks for new events in the queue and triggers their registered callbacks. (not needed when using 'Run')
func (g *Game) Update() error {
	_, ok, err := g.socket.NextEvent()
	for ok && err == nil {
		_, ok, err = g.socket.NextEvent()
	}
	return err
}

// ResolveUsername returns the username associated with playerId.
func (g *Game) ResolveUsername(playerId string) string {
	return g.socket.ResolveUsername(playerId)
}

// Session returns details of the current session.
func (g *Game) Session() cg.Session {
	return g.socket.Session()
}

// Disconnect closes the underlying socket connection.
func (g *Game) Disconnect() error {
	return g.socket.Close()
}

// Leave leaves the game and removes the session from disk.
func (g *Game) Leave() error {
	return g.socket.Leave()
}
