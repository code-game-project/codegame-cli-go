package {{.PackageName}}

/*
This code was generated by codegame-cli-go.

CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
THE CODE IS REGENERATED.
*/

import (
	"fmt"

	"{{.LibraryURL}}"
)

type Game struct {
	ID         string
	Config     GameConfig
	socket     *cg.Socket
	spectating bool
}

// If IsSpectating returns true, the session of this game will be empty and no events can be sent.
func (g *Game) IsSpectating() bool {
	return g.spectating
}

type Player struct {
	ID       string
	Username string
}

// Connect connects a socket to a player.
func Connect(gameURL, gameID, playerID, playerSecret string) (*Game, error) {
	socket, err := cg.NewSocket(gameURL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Connect(gameID, playerID, playerSecret)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to player: %s", err)
	}
	
	config, err := cg.FetchGameConfig[GameConfig](socket, gameID)
	if err != nil {
		return nil, err
	}

	return &Game{
		ID:     socket.Session().GameId,
		Config: config,
		socket: socket,
	}, nil
}

// Spectate connects a socket as a spectator to a game.
func Spectate(gameURL, gameID string) (*Game, error) {
	socket, err := cg.NewSocket(gameURL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Spectate(gameID)
	if err != nil {
		return nil, fmt.Errorf("failed to spectate game: %s", err)
	}
	
	config, err := cg.FetchGameConfig[GameConfig](socket, gameID)
	if err != nil {
		return nil, err
	}

	return &Game{
		ID:     socket.Session().GameId,
		Config: config,
		socket: socket,
	}, nil
}

// Run starts the event loop (blocking).
func (g *Game) Run() error {
	return g.socket.RunEventLoop()
}

// Update looks for new events in the queue and triggers their registered callbacks. (not needed when using 'Run')
func (g *Game) Update() error {
	_, ok, err := g.socket.NextEvent()
	for ok && err == nil {
		_, ok, err = g.socket.NextEvent()
	}
	return err
}

// Username returns the username associated with playerID.
func (g *Game) Username(playerID string) string {
	return g.socket.Username(playerID)
}

// Session returns details of the current session.
func (g *Game) Session() cg.Session {
	return g.socket.Session()
}

// Disconnect closes the underlying socket connection.
func (g *Game) Disconnect() error {
	return g.socket.Close()
}
