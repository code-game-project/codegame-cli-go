package {{.PackageName}}

/*
This code was generated by codegame-cli-go.

CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
THE CODE IS REGENERATED.
*/

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"{{.LibraryURL}}"
	"github.com/mattn/go-colorable"
	"github.com/spf13/pflag"
)

var (
	URL string
	out = colorable.NewColorableStdout()
)

func init() {
	url := os.Getenv("CG_GAME_URL")
	if url != "" {
		URL = url
	}
}

type Game struct {
	Id         string
	Config     GameConfig
	socket     *cg.Socket
	spectating bool
}

// If IsSpectating returns true, the session of this game will be empty and no events can be sent.
func (g *Game) IsSpectating() bool {
	return g.spectating
}

type Player struct {
	Id       string
	Username string
}

// Init parses command line arguments with pflag and calls either CreateAndJoinGame, CreateAndSpectateGame, JoinGame, SpectateGame or ReconnectGame depending on the provided commands:
//
//     Operations:\n")
//         create <username>                         Create a new game.
//         join <game_id> <username> <join_secret?>  Join an existing game.
//         reconnect <username>                      Reconnect to a previous session.
//     Flags:
//         --public    Make the created game public.
//         --protected Make the created game protected.
//         --spectate  Spectate the created/joined game. The username is not neccessary if this flag is set.
//
// This function calls pflag.Parse() internally. If you want to add your own flags, you will need to register them with pflag *before* calling this function.
func Init(config GameConfig) (*Game, error) {
	pflag.Usage = func() {
		fmt.Fprintf(os.Stderr, "USAGE: %s [OPTIONS] <operation>\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "\nOperations:\n")
		fmt.Fprintf(os.Stderr, "  create <username>                         Create a new game.\n")
		fmt.Fprintf(os.Stderr, "  join <game_id> <username> <join_secret?>  Join an existing game.\n")
		fmt.Fprintf(os.Stderr, "  reconnect <username>                      Reconnect to a previous session.\n")
		fmt.Fprintf(os.Stderr, "\nFlags:\n")
		pflag.PrintDefaults()
	}

	var public bool
	pflag.BoolVar(&public, "public", false, "Make the created game public.")
	var protected bool
	pflag.BoolVar(&protected, "protected", false, "Make the created game protected.")
	var spectate bool
	pflag.BoolVar(&spectate, "spectate", false, "Spectate the created/joined game. The username is not neccessary if this flag is set.")
	pflag.Parse()

	var operation string
	if pflag.NArg() > 1 || (spectate && pflag.NArg() > 0) {
		operation = strings.ToLower(pflag.Arg(0))
	} else {
		pflag.Usage()
		os.Exit(1)
	}

	if URL == "" {
		return nil, errors.New("CG_GAME_URL is empty.")
	}

	var game *Game
	var err error
	switch operation {
	case "create":
		var joinSecret string
		if spectate {
			game, joinSecret, err = CreateAndSpectateGame(public, protected, config)
		} else {
			game, joinSecret, err = CreateAndJoinGame(public, protected, pflag.Arg(1), config)
		}
		if game != nil {
			fmt.Println("Game ID:", game.Id)
		}
		if joinSecret != "" {
			fmt.Println("Join secret:", joinSecret)
		}
	case "join":
		if (!spectate && pflag.NArg() < 3) || (spectate && pflag.NArg() < 2) {
			fmt.Fprintln(os.Stderr, "No game_id specified!")
			pflag.Usage()
			os.Exit(1)
		}
		if spectate {
			game, err = SpectateGame(pflag.Arg(1))
		} else {
			var joinSecret string
			if pflag.NArg() > 3 {
				joinSecret = pflag.Arg(3)
			}
			game, err = JoinGame(pflag.Arg(1), pflag.Arg(2), joinSecret)
		}
	case "reconnect":
		game, err = ReconnectGame(pflag.Arg(1))
	default:
		fmt.Fprintf(os.Stderr, "Invalid operation '%s'!\n", operation)
		pflag.Usage()
		os.Exit(1)
	}
	if err != nil {
		return nil, err
	}

	return game, nil
}

// CreateAndJoinGame creates a new game and joins it immediately after.
func CreateAndJoinGame(public, protected bool, username string, config GameConfig) (*Game, string, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, "", fmt.Errorf("failed to connect to server: %s", err)
	}

	gameId, joinSecret, err := socket.CreateGame(public, protected, config)
	if err != nil {
		return nil, "", fmt.Errorf("failed to create game: %s", err)
	}

	err = socket.Join(gameId, username, joinSecret)
	if err != nil {
		return nil, "", fmt.Errorf("failed to join game: %s", err)
	}

	config, err = cg.FetchGameConfig[GameConfig](socket, gameId)
	if err != nil {
		return nil, "", err
	}

	return newGame(gameId, config, socket), joinSecret, nil
}

// CreateAndSpectateGame creates a new game and spectates it immediately after.
func CreateAndSpectateGame(public, protected bool, config GameConfig) (*Game, string, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, "", fmt.Errorf("failed to connect to server: %s", err)
	}

	gameId, joinSecret, err := socket.CreateGame(public, protected, config)
	if err != nil {
		return nil, "", fmt.Errorf("failed to create game: %s", err)
	}

	err = socket.Spectate(gameId)
	if err != nil {
		return nil, "", fmt.Errorf("failed to spectate game: %s", err)
	}

	config, err = cg.FetchGameConfig[GameConfig](socket, gameId)
	if err != nil {
		return nil, "", err
	}

	return newGame(gameId, config, socket), joinSecret, nil
}

// JoinGame joins the game with the specified id.
// Leave joinSecret empty if the game is not protected.
func JoinGame(gameId, username, joinSecret string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Join(gameId, username, joinSecret)
	if err != nil {
		return nil, fmt.Errorf("failed to join game: %s", err)
	}

	config, err := cg.FetchGameConfig[GameConfig](socket, gameId)
	if err != nil {
		return nil, err
	}

	return newGame(gameId, config, socket), nil
}

// ReconnectGame joins a previous session from the session store.
func ReconnectGame(username string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.RestoreSession(username)
	if err != nil {
		return nil, fmt.Errorf("failed to reconnect: %s", err)
	}

	config, err := cg.FetchGameConfig[GameConfig](socket, socket.Session().GameId)
	if err != nil {
		return nil, err
	}

	return newGame(socket.Session().GameId, config, socket), nil
}

// SpectateGame joins a game as a spectator.
func SpectateGame(gameId string) (*Game, error) {
	socket, err := cg.NewSocket(URL)
	if err != nil {
		return nil, fmt.Errorf("failed to connect to server: %s", err)
	}

	err = socket.Spectate(gameId)
	if err != nil {
		return nil, fmt.Errorf("failed to spectate game: %s", err)
	}
	
	config, err := cg.FetchGameConfig[GameConfig](socket, gameId)
	if err != nil {
		return nil, err
	}

	return newGame(socket.Session().GameId, config, socket), nil
}

// Run starts the event loop (blocking).
func (g *Game) Run() error {
	return g.socket.RunEventLoop()
}

// Update looks for new events in the queue and triggers their registered callbacks. (not needed when using 'Run')
func (g *Game) Update() error {
	_, ok, err := g.socket.NextEvent()
	for ok && err == nil {
		_, ok, err = g.socket.NextEvent()
	}
	return err
}

// Username returns the username associated with playerId.
func (g *Game) Username(playerId string) string {
	return g.socket.Username(playerId)
}

// Session returns details of the current session.
func (g *Game) Session() cg.Session {
	return g.socket.Session()
}

// Disconnect closes the underlying socket connection.
func (g *Game) Disconnect() error {
	return g.socket.Close()
}

func newGame(id string, config GameConfig, socket *cg.Socket) *Game {
	wrapperVersion := os.Getenv("CG_GAME_VERSION")
	wrapperVersionParts := strings.Split(wrapperVersion, ".")
	version := socket.Info().Version
	versionParts := strings.Split(version, ".")

	if len(wrapperVersionParts) >= 2 && len(versionParts) >= 2 && strings.Join(strings.Split(version, ".")[:2], ".") != strings.Join(strings.Split(wrapperVersion, ".")[:2], ".") {
		fmt.Fprintf(out, "\x1b[33mWARNING: Game version mismatch. Server: v%s, client: v%s. Please run `codegame update`.\x1b[0m\n", version, wrapperVersion)
	}

	return &Game{
		Id:     id,
		Config: config,
		socket: socket,
	}
}
